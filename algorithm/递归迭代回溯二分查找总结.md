- [1.递归和迭代](#1递归和迭代)
- [2.递归和回溯](#2递归和回溯)
- [3.二分查找（迭代实现）](#3二分查找迭代实现)
- [4.二分查找（递归实现）](#4二分查找递归实现)
- [5.动态规划](#5动态规划)
- [6.动态规划、回溯、递归](#6动态规划回溯递归)

##### 1.递归和迭代
```
相同点：递归和迭代都是一种循环
不同点：
    1、递归是自己通过调用自己的函数实现循环，在指定的条件下停止并返回结果给上一个调用
       递归可以理解是一个树结构，子节点就是基本条件，这个基本条件还是指定的终止条件，一层一层的向下调用
       递归需要具备的条件：
            子问题须与原始问题为同样的事，且更为简单
            不能无限制地调用本身，须有个出口，化简为非递归状况处理。必须要有边界终止条件
        
    2、迭代就是一个环形路径，根据变量递增进行计算  

    递归代码原理总结：
       递归是借助栈实现的，先入后出，每次调用都会压入栈，直到最后一次执行（这个时候就是利用的递归终止条件），
       然后根据最后一次执行的结果依次传值出栈，所有的调用出栈后，该递归结束
       这就是没有递归终止条件的话，一直入栈，导致栈内存溢出的原因
```
```java

递归伪代码：
    function(n){
        if (满足某个条件) {
            return 特定值;
        } else {
            function(n-1);
        }
    }
```

##### 2.递归和回溯
```
递归：基本性质就是函数调用，在处理问题的时候，递归往往是把一个大规模的问题不断地变小，然后进行推导的过程
回溯：则是利用递归的性质，从问题的起始点出发，不断地进行尝试，回头一步甚至多步再做选择，直到最终抵达终点的过程，回溯跟递归一样都是一个树形结构，但是不同点是回溯需要剪枝，剪掉的就是不符合条件的路径，并返回上一个路径

回溯也就是在穷举，一步一步的尝试，如果当前的情况已经无法满足要求，那么久没有必要继续进行下去，避免走弯路
回溯函数在调用的时候，需要带着上一个路径的处理结果

```
```java
回溯伪代码
function(n) {
    // val value = 记住结果;
    backtrack(n, value, list);
}

backtrack(n, value, list) {
    
    if (符合题目条件 == value) {
        list.add(value);
        // java写法如果需要返回List<List<Integer>> 需要使用 list.add(new ArrayList<value>); 
        // 因为java中是值传递，这里需要进行一次拷贝操作，否则结果是空集合
        return;
    }

   for (int i = 0; i < length; i ++) {
     // 执行回溯
    backtrack(i+1, list);
    // 一个路径回溯完成后需对上一个路径进行处理
    value.remove(value.length-1); // 简单举例
   }
}

```

##### 3.二分查找（迭代实现）
```
二分查找也叫折半查找，使用的前提是，数组需要是有序的，时间复杂度在log(n)级别
每次处理的范围缩小到一半
对于二分查找，应该明确每次二分后应该从哪边开始查找，然后要注意边界问题，找到后进行返回查询的结果
```
```java
伪代码
nums数组假设升序
function(nums, target) {

    // 特殊情况判断
    if (nums== null || nums.length == 0 ) {
        return -1;
    }
    // 定义左右边界
    val left = 0;
    val right = nums.length -1;
    // 折半
    val mid = (left + right) / 2;

    while (left <= right) {
        if (nums[mid] == target) {
            // 说明目标值就是中间的值
            return mid;
        }
        if (nums[mid] > target) {
            // 说明目标值在左边的一半,重新定义右边界
            right = mid - 1;
        } else {
            // 说明目标值在右边的一半，重新定义左边界
            left = mid + 1;
        }
    }
    // 找不到，返回题目指定的值
    return -1;
}
```

##### 4.二分查找（递归实现）
```
二分查找的原理是一样的，都是折半，不过是使用递归去实现
```
```java
function(target) {
    // 特殊情况判断
    if (nums== null || nums.length == 0 ) {
        return -1;
    }
    return binarySearch(nums, 0, nums.length-1, target);
}

function binarySearch(nums, left, right, target) {
    // 左边界大于右边界的时候，说明根本没有找到，结束函数
    if (left > right) {
        return -1;
    }

    // 折半
    val mid = (left + right) / 2;
    // 递归终止条件,每个递归都需要找到类似的终止条件
    if (nums[mid] == target) {
        return mid;
    }
    if (nums[mid] > target) {
        // 说明目标值在左边的一半，重新定义右边界
        right = mid-1;
        return binarySearch(nums, left, right, target);
    } else {
        // 说明目标值在右边的一半，重新定义左边界
        left = mid + 1;
        return binarySearch(nums, left, right, target);
    }
}
```

##### 5.动态规划
```
动态规划思路：
    动态规划适用于解决最优子结构的问题
    动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。
    这也就是动态规划被称为备忘录算法的原因，就是需要dp来记录上一步的计算值
    动态规划题的三个步骤：
        第一步骤：定义数组元素的含义，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？
        第二步骤：找出数组元素之间的关系式，我觉得动态规划，还是有一点类似于我们高中学习时的归纳法的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2].....dp[1]，来推出 dp[n] 的，也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了
        第三步骤：找出初始值。虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是所谓的初始值。

    简单案例：青蛙跳台阶
        一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
        1.定义数组元素的含义：dp[n] 就是在第n级台阶有多少跳法
        2.数组元素之间的关系式：dp[n] = dp[n-1] + dp[n-2]
        3.初始值：dp[1] = 1, dp[2] = 2; 因为跳上第2级台阶有两种跳法，一下跳上去和两下跳上去

    二维数组案例：62：不同路径
        一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
        机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
        问总共有多少条不同的路径？
        链接：https://leetcode.cn/problems/unique-paths

        1.定义数组的元素：dp[i][j] 就是到网格i x j 的路径
        2.数组元素之间的关系式：dp[i][j] = dp[i-1][j] + dp[i]dp[j-1];
             从 (i-1, j) 这个位置走一步到达 和 从(i, j - 1) 这个位置走一步到达
        3.初始值：
                dp[0] [0….n-1] = 1; // 相当于最上面一行，机器人只能一直往右走
                dp[0…m-1] [0] = 1; // 相当于最左面一列，机器人只能一直往下走

    二维数组案例：64. 最小路径和
        给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
        说明：每次只能向下或者向右移动一步。
        链接：https://leetcode.cn/problems/minimum-path-sum/
        
        1.定义数组元素：dp[i][j] 就是到网格i x j 的路径和
        2.数组元素之间的关系式：dp[i][j] = min(dp[i-1][j] + dp[i]dp[j-1]) + arr[i][j];
            从 (i-1, j) 这个位置走一步到达 和 从(i, j - 1) 这个位置走一步到达的路径，两个路径和的最小值 + // arr[i][j] 表示网格中的值
        3.初始值：
            dp[0] [j] = arr[0] [j] + dp[0] [j-1]; // 相当于最上面一行，机器人只能一直往左走
            dp[i] [0] = arr[i] [0] + dp[i] [0]; // 相当于最左面一列，机器人只能一直往下走

    hard案例：72. 编辑距离
        给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。
        你可以对一个单词进行如下三种操作：
            插入一个字符
            删除一个字符
            替换一个字符
        链接：https://leetcode.cn/problems/edit-distance/

        1.定义数组的元素：当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i] [j]。
        2.数组元素之间的关系式：（不好找）
            根据三种操作：
                如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i] [j] = dp[i-1] [j-1] + 1;
                如果在字符串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i] [j] = dp[i] [j-1] + 1;
                如果把字符 word1[i] 删除，则有 dp[i] [j] = dp[i-1] [j] + 1;
            那么我们应该选择一种操作，使得 dp[i] [j] 的值最小，显然有
            dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;
        3.初始值：
            当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，
            所以我们的初始值是计算出所有的 dp[0] [0….n] 和所有的 dp[0….m] [0]。这个还是非常容易计算的，因为当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了。
```
```java
//简单案例：青蛙跳台阶
function(n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    int[] dp = new int[n+1];
    for(int i = 3; i <= n; i++) {
        dp[n] = dp[n-1] + dp[n-2];
    }
    return dp[n]
}

// 严谨一点来讲，这个是递归实现的动态规划，需要掌握三个步骤
function getNSum(n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    return getNSum(n-1) + getNSum(n-2);
}

```

```java
// 二维数组案例：62：不同路径
function(m, n) {
    if (m <= 0 || n <= 0) {
        return 0;
    }

    int[][] dp = new int[m][n]; // 
    // 初始化
    for(int i = 0; i < m; i++){
      dp[i][0] = 1;
    }
    for(int i = 0; i < n; i++){
      dp[0][i] = 1;
    }
        // 推导出 dp[m-1][n-1]
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    return dp[m-1][n-1];
}
```

```java
//二维数组案例：64. 最小路径和
function(arr) {
    int m = arr.length;
    int n = arr[0].length;
    if (m <= 0 || n <= 0) {
        return 0;
    }

    int[][] dp = new int[m][n]; // 
    // 初始化
    dp[0][0] = arr[0][0];
    // 初始化最左边的列
    for(int i = 1; i < m; i++){
      dp[i][0] = dp[i-1][0] + arr[i][0];
    }
    // 初始化最上边的行
    for(int i = 1; i < n; i++){
      dp[0][i] = dp[0][i-1] + arr[0][i];
    }
        // 推导出 dp[m-1][n-1]
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + arr[i][j];
        }
    }
    return dp[m-1][n-1];
}
```

```java
//hard案例：72. 编辑距离
function minDistance(String word1, String word2) {
    int n1 = word1.length();
    int n2 = word2.length();
    int[][] dp = new int[n1 + 1][n2 + 1];
    // dp[0][0...n2]的初始值
    for (int j = 1; j <= n2; j++) 
        dp[0][j] = dp[0][j - 1] + 1;
    // dp[0...n1][0] 的初始值
    for (int i = 1; i <= n1; i++) dp[i][0] = dp[i - 1][0] + 1;
        // 通过公式推出 dp[n1][n2]
    for (int i = 1; i <= n1; i++) {
        for (int j = 1; j <= n2; j++) {
            // 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1
            if (word1.charAt(i - 1) == word2.charAt(j - 1)){
                p[i][j] = dp[i - 1][j - 1];
            }else {
               dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;
            }         
        }
    }
    return dp[n1][n2];  
}
```

##### 6.动态规划、回溯、递归
```
1.前面说过递归就是自我调用，比如题主问题中的DFS 、动态规划、回溯法都可以用递归来实现，当然也可以用非递归来实现。
2.回溯是一种通用的算法，把问题分步解决，在每一步都试验所有的可能，当发现已经找到一种方式或者目前这种方式不可能是结果的时候，退回上一步继续尝试其他可能。很多时候每一步的处理都是一致的，这时候用递归来实现就很自然。
    当回溯用于树的时候，就是深度优先搜索。当然了，几乎所有可以用回溯解决的问题都可以表示为树。那么这俩在这里就几乎同义了。如果一个问题解决的时候显式地使用了树，那么我们就叫它dfs。
    很多时候没有用树我们也管它叫dfs严格地说是不对的，但是dfs比回溯打字的时候好输入。
3.动态规划:回溯可以用于所有用穷举法可以解决的问题，而DP只用于具有最优子结构的问题。所以不是所有问题都适合用dp来解决，比如八皇后。dp需要存贮子问题的解，回溯不需要。
```
