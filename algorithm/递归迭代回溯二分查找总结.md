- [1.递归和迭代](#1递归和迭代)
- [2.递归和回溯](#2递归和回溯)
- [3.二分查找（迭代实现）](#3二分查找迭代实现)
- [4.二分查找（递归实现）](#4二分查找递归实现)
##### 1.递归和迭代
```
相同点：递归和迭代都是一种循环
不同点：
    1、递归是自己通过调用自己的函数实现循环，在指定的条件下停止并返回结果给上一个调用
       递归可以理解是一个树结构，子节点就是基本条件，这个基本条件还是指定的终止条件，一层一层的向下调用
       递归需要具备的条件：
            子问题须与原始问题为同样的事，且更为简单
            不能无限制地调用本身，须有个出口，化简为非递归状况处理。必须要有边界终止条件
        
    2、迭代就是一个环形路径，根据变量递增进行计算  

    递归代码原理总结：
       递归是借助栈实现的，先入后出，每次调用都会压入栈，直到最后一次执行（这个时候就是利用的递归终止条件），
       然后根据最后一次执行的结果依次传值出栈，所有的调用出栈后，该递归结束
       这就是没有递归终止条件的话，一直入栈，导致栈内存溢出的原因
```
```java

递归伪代码：
    function(n){
        if (满足某个条件) {
            return 特定值;
        } else {
            function(n-1);
        }
    }
```

##### 2.递归和回溯
```
递归：基本性质就是函数调用，在处理问题的时候，递归往往是把一个大规模的问题不断地变小，然后进行推导的过程
回溯：则是利用递归的性质，从问题的起始点出发，不断地进行尝试，回头一步甚至多步再做选择，直到最终抵达终点的过程，回溯跟递归一样都是一个树形结构，但是不同点是回溯需要剪枝，剪掉的就是不符合条件的路径，并返回上一个路径

回溯也就是在穷举，一步一步的尝试，如果当前的情况已经无法满足要求，那么久没有必要继续进行下去，避免走弯路
回溯函数在调用的时候，需要带着上一个路径的处理结果

```
```java
回溯伪代码
function(n) {
    // val value = 记住结果;
    backtrack(n, value, list);
}

backtrack(n, value, list) {
    
    if (符合题目条件 == value) {
        list.add(value);
        // java写法如果需要返回List<List<Integer>> 需要使用 list.add(new ArrayList<value>); 
        // 因为java中是值传递，这里需要进行一次拷贝操作，否则结果是空集合
        return;
    }

   for (int i = 0; i < length; i ++) {
     // 执行回溯
    backtrack(i+1, list);
    // 一个路径回溯完成后需对上一个路径进行处理
    value.remove(value.length-1); // 简单举例
   }
}

```

##### 3.二分查找（迭代实现）
```
二分查找也叫折半查找，使用的前提是，数组需要是有序的，时间复杂度在log(n)级别
每次处理的范围缩小到一半
对于二分查找，应该明确每次二分后应该从哪边开始查找，然后要注意边界问题，找到后进行返回查询的结果
```
```java
伪代码
nums数组假设升序
function(nums, target) {

    // 特殊情况判断
    if (nums== null || nums.length == 0 ) {
        return -1;
    }
    // 定义左右边界
    val left = 0;
    val right = nums.length -1;
    // 折半
    val mid = (left + right) / 2;

    while (left <= right) {
        if (nums[mid] == target) {
            // 说明目标值就是中间的值
            return mid;
        }
        if (nums[mid] > target) {
            // 说明目标值在左边的一半,重新定义右边界
            right = mid - 1;
        } else {
            // 说明目标值在右边的一半，重新定义左边界
            left = mid + 1;
        }
    }
    // 找不到，返回题目指定的值
    return -1;
}
```

##### 4.二分查找（递归实现）
```
二分查找的原理是一样的，都是折半，不过是使用递归去实现
```
```java
function(target) {
    // 特殊情况判断
    if (nums== null || nums.length == 0 ) {
        return -1;
    }
    return binarySearch(nums, 0, nums.length-1, target);
}

function binarySearch(nums, left, right, target) {
    // 左边界大于右边界的时候，说明根本没有找到，结束函数
    if (left > right) {
        return -1;
    }

    // 折半
    val mid = (left + right) / 2;
    // 递归终止条件,每个递归都需要找到类似的终止条件
    if (nums[mid] == target) {
        return mid;
    }
    if (nums[mid] > target) {
        // 说明目标值在左边的一半，重新定义右边界
        right = mid-1;
        return binarySearch(nums, left, right, target);
    } else {
        // 说明目标值在右边的一半，重新定义左边界
        left = mid + 1;
        return binarySearch(nums, left, right, target);
    }
}
```
